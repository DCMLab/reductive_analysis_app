<html>
    <head>
        <title>Verovio Hello World! example</title>
        <!--/////////////////////-->
        <!-- The Verovio toolkit -->
        <!--/////////////////////-->
        <script src="js/verovio-toolkit.js" type="text/javascript" ></script>
        <!--////////////////////-->
        <!-- We also use jQuery -->
        <!--////////////////////-->
        <script src="https://code.jquery.com/jquery-3.1.1.min.js" type="text/javascript" ></script>
        <!--/////////////////////-->
        <!-- And D3JS            -->
        <!--/////////////////////-->
        <script src="js/d3.min.js" type="text/javascript" ></script>
    </head>
    <body>

        <script type="text/javascript">
	    // Clicking selects
            var selected = [];
	    // Shift-clicking extra selects
            var extraselected = [];
	    // Load Verovio
            var vrvToolkit = new verovio.toolkit();
	    // This is our SVG
	    var svg;
	    // And the underlying MEI
	    var mei;
	    // And the graph node in the MEI
	    var mei_graph;
	    // This is the MEI as text (pre-parse)
	    var data;
	    // We need a reader
	    var reader = new FileReader();
	    // Did we change the MEI somehow?
	    var changes = false;
	    // Our undo stack. TODO: is this being empty the same as
	    // changes being false?
	    var undo_actions = [];

	    var redo_actions = []; //TODO, maybe?

	    var reduce_actions = [];

	    var non_notes_hidden = false;

	    // Vector operations, taken from 
	    // http://bl.ocks.org/hollasch/f70f1fe7700f092b5a505e3efd1d9232
	    var vecScale = function (scale, v) {
	          // Returns the vector 'v' scaled by 'scale'.
	          return [ scale * v[0], scale * v[1] ];
	    }

	    var vecSum = function (pv1, pv2) {
		  // Returns the sum of two vectors, or a combination of a point and a
		  // vector.
		  return [ pv1[0] + pv2[0], pv1[1] + pv2[1] ];
	    }

	    var unitNormal = function (p0, p1) {
		  // Returns the unit normal to the line segment from p0 to p1.
		  var n = [ p0[1] - p1[1], p1[0] - p0[0] ];
		  var nLength = Math.sqrt (n[0]*n[0] + n[1]*n[1]);
		  return [ n[0] / nLength, n[1] / nLength ];
	    };


	    // Toggle if a thing (for now: note) is selected or not.
            function toggle_selected(item,extra) { 
	      if(selected.find(x => x === item) || extraselected.find(x => x === item)) {
		item.setAttribute("style","fill:black");
		selected = selected.filter(x =>  x !== item);
		extraselected = extraselected.filter(x =>  x !== item);
	      } else {
		if(extra) {
		  item.setAttribute("style","fill:red");
		  extraselected.push(item);
		}else {
		  item.setAttribute("style","fill:green");
		  selected.push(item);
		}
	      }
	    }
            // Get the MEI-graph nodes that are adjacent to a hyperedge
            function hyperedge_allnodes(he) {
	      var arcs_array = Array.from(mei_graph.getElementsByTagName("arc"));
	      var nodes = [];
	      arcs_array.forEach(function (a) {
		    if(a.getAttribute("from") == "#"+he.getAttribute("xml:id")){
		      nodes.push(get_by_id(mei,a.getAttribute("to")));
		    }
		  });
	      return nodes;
	    }
            // Get the MEI-graph nodes that are adjacent and primary to a hyperedge
            function hyperedge_primaries(he) {
	      var arcs_array = Array.from(mei_graph.getElementsByTagName("arc"));
	      var nodes = [];
	      arcs_array.forEach(function (a) {
		if(a.getAttribute("from") == "#"+he.getAttribute("xml:id") &&
		   a.getAttribute("type") == "primary"){
		  nodes.push(get_by_id(mei,a.getAttribute("to")));
		}
		  });
	      return nodes;
	    }
            // Get the MEI-graph nodes that are adjacent and secondary to a hyperedge
            function hyperedge_secondaries(he) {
	      var arcs_array = Array.from(mei_graph.getElementsByTagName("arc"));
	      var nodes = [];
	      arcs_array.forEach(function (a) {
		if(a.getAttribute("from") == "#"+he.getAttribute("xml:id") &&
		   a.getAttribute("type") == "secondary"){
		  nodes.push(get_by_id(mei,a.getAttribute("to")));
		}
		  });
	      return nodes;
	    }

            // This reduces away the hyperedges where all the secondaries
	    // are not primary in any non-reduced hyperedge. TODO: This is
	    // a very stupid implementation akin to bubble sort. No doubt
	    // the complexity and performance can be _greatly_ improved.
            function do_reduce() {
	      var nodes_array = Array.from(mei_graph.getElementsByTagName("node"));
	      // Get the nodes representing hyperedges
	      var hyperedges_nodes = nodes_array.filter(function(x) { return x.getAttribute("type") == "hyperedge";})
	      var remaining_hyperedges = hyperedges_nodes.filter(function(x) { 
		return reduce_actions.flat().flat().findIndex(function(y) {return y == x; }) == -1
	      });
	      var reduce_action = [];
	      // For each remaining hyperedge
	      if(remaining_hyperedges.length == 0){
		console.log("No reduction possible");
		return;
	      }

	      remaining_hyperedges.forEach(function (he) {
	        var secondaries = hyperedge_secondaries(he); 
		// If none of this hyperedges secondary nodes are such that
		if( 0 == secondaries.filter(function(x) { 
		  // Any other remaining hyperedge
	 	  return 0 != remaining_hyperedges.filter( function (hf) {
		    // Has it as a primary
		    return hyperedge_primaries(hf).findIndex(function(y) {return x == y;}) != -1;
		  }).length;
		}).length){
		  // Then we can safely reduce this hyperedge
		  reduce_action.push(he);
		}
	      });
	      reduce_actions.push(reduce_action.map(function(he) {
		var secondaries = hyperedge_secondaries(he);
		var graphicals = [];
		graphicals.push(secondaries.map(hide_note));
		graphicals.push(hide_he(he));
		return [he,secondaries,graphicals];
	      }));
	    }

            function undo_reduce() {
	      var reduce_layer = reduce_actions.pop();
	      reduce_layer.forEach(function(action) {
		var [he,secondaries,graphicals] = action;
		graphicals.flat().forEach(function(x) { x.style.visibility = "visible";});
		secondaries.forEach(function(x) { mark_secondary(get_by_id(document,note_get_sameas(x))); });
	      });

	    }


            function hide_note(note) {
	      var elem = get_by_id(document,note_get_sameas(note));
	      elem.style.visibility = "hidden";
	      return elem;
	    }

            function hide_he(he) {
	      var elem = get_by_id(document,he.getAttribute("xml:id"));
	      elem.style.visibility = "hidden";
	      return elem;
	    }

            function mark_secondary(item) {
		item.setAttribute("style","fill:grey");
	    }

	    var roundedHull2 = function (polyPoints) {
		// Returns the path for a rounded hull around two points (a "capsule" shape).
	      var hullPadding = 200;

		var offsetVector = vecScale (hullPadding, unitNormal (polyPoints[0], polyPoints[1]));
		var invOffsetVector = vecScale (-1, offsetVector);
		// around that note coordinates are not at the centroids

		var p0 = vecSum (polyPoints[0], offsetVector);
		var p1 = vecSum (polyPoints[1], offsetVector);
		var p2 = vecSum (polyPoints[1], invOffsetVector);
		var p3 = vecSum (polyPoints[0], invOffsetVector);

		return 'M ' + p0
		    + ' L ' + p1 + ' A ' + [hullPadding, hullPadding, '0,0,0', p2].join(',')
		    + ' L ' + p3 + ' A ' + [hullPadding, hullPadding, '0,0,0', p0].join(',');
	    };

	    var roundedHullN = function (polyPoints) {
	      var hullPadding = 200;
		// Returns the SVG path data string representing the polygon, expanded and rounded.

		// Handle special cases
		if (!polyPoints || polyPoints.length < 1) return "";
		if (polyPoints.length === 1) return roundedHull1 (polyPoints);
		if (polyPoints.length === 2) return roundedHull2 (polyPoints);

		var segments = new Array (polyPoints.length);

		// Calculate each offset (outwards) segment of the convex hull.
		for (var segmentIndex = 0;  segmentIndex < segments.length;  ++segmentIndex) {
		    var p0 = (segmentIndex === 0) ? polyPoints[polyPoints.length-1] : polyPoints[segmentIndex-1];
		    var p1 = polyPoints[segmentIndex];

		    // Compute the offset vector for the line segment, with length = hullPadding.
		    var offset = vecScale (hullPadding, unitNormal (p0, p1));

		    segments[segmentIndex] = [ vecSum (p0, offset), vecSum (p1, offset) ];
		}

		var arcData = 'A ' + [hullPadding, hullPadding, '0,0,0,'].join(',');

		segments = segments.map (function (segment, index) {
		    var pathFragment = "";
		    if (index === 0) {
			var pathFragment = 'M ' + segments[segments.length-1][1] + ' ';
		    }
		    pathFragment += arcData + segment[0] + ' L ' + segment[1];

		    return pathFragment;
		});

		return segments.join(' ');
	    }

            function roundedHull(points) {
	      var sibling = document.getElementsByClassName("system")[0];
	      var parent = sibling.parentNode;
	      var newElement = document.createElementNS("http://www.w3.org/2000/svg", 'path');
	      newElement.setAttribute('fill', '#aca');
	      if(points.length == 2) {
		newElement.setAttribute('d',roundedHull2(points));
	      } else {
		newElement.setAttribute('d',roundedHullN(d3.polygonHull(points)));
	      }
	      parent.insertBefore(newElement,sibling);
	      return newElement;
	    }



            // Draw a line between points p1 and p2
            function line(p1,p2) {
	      var sibling = document.getElementsByClassName("system")[0];
	      var parent = sibling.parentNode;
	      var newElement = document.createElementNS("http://www.w3.org/2000/svg", 'line');
	      newElement.setAttribute("x1",p1[0]);
	      newElement.setAttribute("y1",p1[1]);
	      newElement.setAttribute("x2",p2[0]);
	      newElement.setAttribute("y2",p2[1]);
	      newElement.style.stroke = "#000";
	      newElement.style.strokeWidth = "15px"; 
	      parent.appendChild(newElement);
	      return newElement;
	    }

            function note_coords(note) {
	      return [note.getElementsByTagName("use")[0].x.animVal.value + 100,
		      note.getElementsByTagName("use")[0].y.animVal.value]
	    }

            // Draw a series of edges (TODO: make it much much much better)
            function draw_edges() {
	      var added = [];
	      for(var i = 1; i < selected.length; i++) {
		note1 = note_coords(selected[i-1]);
		note2 = note_coords(selected[i]);
		//added.push(line(note1,note2));
		added.push(roundedHull([note1,note2]));
	      // TODO: Add selectability on edge.
	      }
	      return added;
	    }

            function add_mei_node_for(note) {
	        var id = note.getAttribute("id");
		var elem = get_by_id(mei,"gn-"+id);
		if (elem != null) {
		  return elem;
		}
		elem = mei.createElement("node");
		// This node represent that note
		var label = mei.createElement("label");
		var note = mei.createElement("note");
		note.setAttribute("sameas","#"+id);
		elem.appendChild(label);
		label.appendChild(note);
		// But should have a separate XML ID
		elem.setAttribute("xml:id","gn-" + id);
		mei_graph.appendChild(elem);
		return elem;
	    }
            
            // Add a collection of edges to the MEI graph element
            function add_edges() {
	      var added = [];
	      for(var i = 0; i < selected.length; i++) {
		var elem = add_mei_node_for(selected[i]);
		added.push(elem);
	      }
	      for(var i = 1; i < selected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#gn-"+selected[i-1].getAttribute("id"));
		elem.setAttribute("to","#gn-"+selected[i].getAttribute("id"));
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      return added;
	    }

            // Draw a hyperedge as a  series of edges (TODO: make it much much much better)
            function draw_hyperedge(id) {
	      var added = [];
	      var notes = selected.concat(extraselected);
	      notes.sort(function(a,b) { 
		  var p1= note_coords(a);
		  var p2= note_coords(b);
		  return (p1[0] - p2[0]) ? (p1[0] - p2[0]) : (p1[1] - p2[1]);
		});


	      //for(var i = 1; i < notes.length; i++) {
		//note1 = note_coords(notes[i-1]);
		//note2 = note_coords(notes[i]);
		//added.push(line(note1,note2));
	        var elem = roundedHull(notes.map(note_coords));
		elem.setAttribute("id",id);
		added.push(elem);
	      // TODO: Add selectability on edge.
	      //}

	      return added;
	    }
            
            // Add a "hyperedge" to the MEI graph element. We model this
	    // with a new node.
            function add_hyperedge() {
	      var added = [];
              // Add new nodes for all notes
	      for(var i = 0; i < selected.length; i++) {
		var elem = add_mei_node_for(selected[i]);
		added.push(elem);
	      }
	      for(var i = 0; i < extraselected.length; i++) {
		var elem = add_mei_node_for(extraselected[i]);
		added.push(elem);
	      }
	      // Add a new node for the hyperedge
	      var he_elem = mei.createElement("node");
	      he_elem.setAttribute("type","hyperedge");
	      // Who knows if this is enough
	      var he_id = "he-"+Math.floor(Math.random() * (1 << 20)).toString(16);
	      he_elem.setAttribute("xml:id",he_id);
	      mei_graph.appendChild(he_elem);
	      added.push(he_elem);
	      for(var i = 0; i < selected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#"+he_id);
		elem.setAttribute("to","#gn-"+selected[i].getAttribute("id"));
		elem.setAttribute("type","secondary");
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      for(var i = 0; i < extraselected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#"+he_id);
		elem.setAttribute("to","#gn-"+extraselected[i].getAttribute("id"));
		elem.setAttribute("type","primary");
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      return [he_id,added];
	    }


	    // OK we've selected stuff, let's make the selection into a
	    // series of edges
	    function do_edges() {
		if (selected.length == 0 && extraselected == 0) {
		  return;}
		changes = true;
		added = [];
		added.push(draw_edges()); // Draw the edge
		added.push(add_edges());  // Add it to the MEI
		
		undo_actions.push([added,selected,extraselected]);
		selected.forEach(toggle_selected); // De-select
		extraselected.forEach(toggle_selected); // De-select
	    }

	    // OK we've selected stuff, let's make the selection into a
	    // "hyperedge".
	    function do_hyperedge() {
		if (selected.length == 0 && extraselected == 0) {
		  return;}
		changes = true;
		added = [];
		var [he_id,mei_elems] = add_hyperedge();
		added.push(mei_elems);  // Add it to the MEI
		added.push(draw_hyperedge(he_id)); // Draw the edge
		
		undo_actions.push([added,selected,extraselected]);
		selected.forEach(mark_secondary); // De-select
		selected = [];
		extraselected.forEach(toggle_selected); // De-select
	    }

            // Oops, undo whatever we did last.
	    function do_undo() {
		// Get latest undo_actions
		[added,sel,extra] = undo_actions.pop();
		// Deselect the current selection, if any
		selected.forEach(toggle_selected);
		extraselected.forEach(function(x) {toggle_selected(x,true);});
		// Remove added elements
		added.flat().forEach(function(x) {
		    if(!node_referred_to(x.getAttribute("xml:id")))
		      x.parentNode.removeChild(x);
		    });
		// Select last selection
		sel.forEach(function(x) {toggle_selected(x);});
		extra.forEach(function(x) {toggle_selected(x,true);});
	    }


            // We have keyboard commands!
            function handleKeypress(ev) {
	      if (ev.key == "Enter"){
		do_edges();
	      } else if (ev.key == "u") { // UNDO
		do_undo();
	      }else {
		console.log(ev.key);
	      }

	    }

	    // Function to download data to a file
            // Taken from StackOverflow answer by Kanchu at
            // https://stackoverflow.com/questions/13405129/javascript-create-and-save-file
	    function download(data, filename, type) {
		var file = new Blob([data], {type: type});
		if (window.navigator.msSaveOrOpenBlob) // IE10+
		    window.navigator.msSaveOrOpenBlob(file, filename);
		else { // Others
		    var a = document.createElement("a"),
			    url = URL.createObjectURL(file);
		    a.href = url;
		    a.download = filename;
		    document.body.appendChild(a);
		    a.click();
		    setTimeout(function() {
			document.body.removeChild(a);
			window.URL.revokeObjectURL(url);  
		    }, 0); 
		}
	    }

            // If the MEI already has a graph, we add on to that. TODO:
	    // Check that the graph is actually our kind of graph
            function add_or_fetch_graph() {
	      var existing = mei.getElementsByTagName("graph");
	      if(existing.length) {
		// TODO: Not just grab the first one.
		return existing[0];
	      }
	      var elem = mei.createElement("graph");
	      elem.setAttribute("type","directed");
	      mei.getElementsByTagName("body")[0].appendChild(elem);
	      return elem;
	    }
  
            // An option to download the MEI with the changes we've made
	    function save() {
	      var saved = new XMLSerializer().serializeToString(mei);
	      download(saved, "download.mei", "text/xml");
	    }

	    // Download the current SVG, including graph elements
	    function savesvg() {
	      var saved = new XMLSerializer().serializeToString($("#svg_output")[0]);
	      download(saved, "download.mei", "text/xml");
	    }

            // Load a new MEI
            function load() {
	      /* Cancel loading if changes are not saved? alert */
	      selected = [];
	      extraselected = [];
	      upload = document.getElementById("fileupload");
	      if(upload.files.length == 1){
		reader.addEventListener("load",load_finish);
		reader.readAsText(upload.files[0]);
	      }else{
		return;
	      }
	    }

            function get_by_id(doc,id) {
	      if (id[0] == "#") { id = id.slice(1); }
	      var elem =  doc.querySelector("[*|id='"+id+"']");
	      if(elem) {
		return elem;
	      }else{
		return Array.from(doc.all).find(function(x) { return x.getAttribute("id") == id || x.getAttribute("xml:id") == id; });
	      }
	    }

            function node_referred_to(id) {
	      return Array.from(mei.getElementsByTagName("arc"))
		.filter(function(x) {
		    return (x.getAttribute("from") == "#"+id || 
			    x.getAttribute("to") == "#"+id);
		 }).length > 0;
	    }

            function note_get_sameas(note) {
	      return note.getElementsByTagName("label")[0].
		          getElementsByTagName("note")[0].
		          getAttribute("sameas");
	    }




            // Draw the existing graph
            function draw_graph() {
	      // There's a multi-stage process to get all the info we
	      // need... First we get the nodes from the graph element.
	      var nodes_array = Array.from(mei_graph.getElementsByTagName("node"));
	      // Get the nodes representing hyperedges
	      var hyperedges_nodes = nodes_array.filter(function(x) { return x.getAttribute("type") == "hyperedge";})
	      // Next we get the note labels
	      var note_ids = nodes_array.map(function(x) {
		            try{
			      return [x, 
			              note_get_sameas(x)]
//			              x.getElementsByTagName("label")[0].getElementsByTagName("note")[0]];
			    }catch{
			      return [];
			    }
			  }).filter(function(x) {return x.length != 0;});
	      // And finally we get the IDs of the actual notes in the MEI
	      // body, which will correspond to the <g>'s in the SVG
	   //   var note_ids = note_nodes.map(function(x) {
	//	    return [x[0],x[1].getAttribute("sameas")];
	//	  });
	      // Now get the arcs/edges
	      var arcs_array = Array.from(mei_graph.getElementsByTagName("arc"));
	      var hyperedges_arcs = [];
	      // And draw them all.
	      arcs_array.forEach(function(x) {
		  var n1 = get_by_id(mei,x.getAttribute("from")); 
		  var n2 = get_by_id(mei,x.getAttribute("to"));
		  if (hyperedges_nodes.findIndex(function (x) {return x == n1;}) == -1){
		    //Regular edge, just draw. TODO: Fix assumption that
		    //nodes are notes if we reach this.
		    var id1 = note_ids.find(function(y) {
			  return y[0] == n1;
			})[1];
		    var id2 = note_ids.find(function(y) {
			  return y[0] == n2;
			})[1];
		    selected = [get_by_id(document,id1),get_by_id(document,id2) ];
		    draw_edges();
		    selected = [];
		  }else{
		    var id2 = note_ids.find(function(y) {
			  return y[0] == n2;
			})[1];
		    hyperedges_arcs.push([n1,id2,x.getAttribute("type")]);
		  }
	      });
	      hyperedges_nodes.forEach(function(x) {
		  var hyperedge_nodes = hyperedges_arcs.
		              filter(function(y) {return y[0] == x;}).
			      map(function(y) {return [y[2],get_by_id(document,y[1])];})
	          selected = hyperedge_nodes.
		              filter(function(y) {return y[0] == "secondary";}).
			      map(function (y) { return y[1];});
	          extraselected = hyperedge_nodes.
		              filter(function(y) {return y[0] == "primary";}).
			      map(function (y) { return y[1];});
		  draw_hyperedge(x.getAttribute("xml:id"));
		  selected.forEach(mark_secondary); // De-select
		  selected = [];
		  extraselected = [];
		});

	    }
            
            // Do all of this when we have the MEI in memory
            function load_finish(e) {
	      data = reader.result;
	      parser = new DOMParser();
	      mei = parser.parseFromString(data,"text/xml");
	      mei_graph = add_or_fetch_graph();
	      svg = vrvToolkit.renderData(data, {pageWidth: 20000,
		  pageHeight: 10000, breaks: "none"});
	      $("#svg_output").html(svg);
	      draw_graph();
	      for (let n of document.getElementsByClassName("note")) {
		  n.addEventListener('click', function(ev) {toggle_selected(n,ev.shiftKey) } )
	      }
	      document.addEventListener('keypress',function(ev) {handleKeypress(ev);});
	    }

            function toggle_equalize() {
	      var svg_element = document.getElementById("svg_output");
	      var hidden = "hidden";
	      if(non_notes_hidden){
		hidden = "visible";
		non_notes_hidden = false;
	      }else{
		non_notes_hidden = true;
	      }
	      Array.from(svg_element.getElementsByClassName("beam")).forEach(function(x)
		  { x.getElementsByTagName("polygon")[0].style.visibility= hidden; });
	      Array.from(svg_element.getElementsByClassName("fermata")).forEach(function(x)
		  { x.style.visibility= hidden; });
	      Array.from(svg_element.getElementsByClassName("rest")).forEach(function(x)
		  { x.style.visibility= hidden; });
	      Array.from(svg_element.getElementsByClassName("stem")).forEach(function(x)
		  { x.style.visibility= hidden; });
	      Array.from(svg_element.getElementsByClassName("flag")).forEach(function(x)
		  { x.style.visibility= hidden; });
	    }




        </script>
	<div id="load_save" style="position:fixed">
	  <input type="file" id="fileupload" value="Load" onchange="load()" >
	  <!--input type="button" id="uploadbutton" value="Load" onclick="load()" -->
	  <input type="button" id="downloadbutton" value="Save" onclick="save()" >
	  <input type="button" id="svgdownloadbutton" value="Save SVG" onclick="savesvg()" >
	  <input type="button" id="edgebutton" value="Add edges" onclick="do_edges()" >
	  <input type="button" id="hyperedgebutton" value="Add hyperedge" onclick="do_hyperedge()" >
	  <input type="button" id="undobutton" value="Undo" onclick="do_undo()" >
	  <input type="button" id="reducebutton" value="Reduce Hyperedges" onclick="do_reduce()" >
	  <input type="button" id="unreducebutton" value="Undo reduction" onclick="undo_reduce()" >
	  <input type="button" id="equalizebutton" value="Toggle stems etc." onclick="toggle_equalize()" >
	</div>

        <!--//////////////////////////////////////////////-->
        <!-- The div where we are going to insert the SVG -->
        <!--//////////////////////////////////////////////-->
	
	<div id="svg_output"></div>



    </body>
</html>
