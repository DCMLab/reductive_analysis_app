<html>
    <head>
        <title>DCML Reductive Analysis Webapp / Redusic / MuseReduce /</title>
        <!--/////////////////////-->
        <!-- The Verovio toolkit -->
        <!--/////////////////////-->
        <script src="js/verovio-toolkit.js" type="text/javascript" ></script>
        <!--////////////////////-->
        <!-- We also use jQuery -->
        <!--////////////////////-->
        <script src="https://code.jquery.com/jquery-3.1.1.min.js" type="text/javascript" ></script>
        <!--/////////////////////-->
        <!-- And D3JS            -->
        <!--/////////////////////-->
        <script src="js/d3.min.js" type="text/javascript" ></script>
	<script src="js/utils.js" type="text/javascript"></script>
    </head>
    <body>

        <script type="text/javascript">
	    // Clicking selects
            var selected = [];
	    // Shift-clicking extra selects
            var extraselected = [];
	    // Load Verovio
            var vrvToolkit = new verovio.toolkit();
	    // This is our SVG
	    var svg;
	    var orig_svg;
	    // And the underlying MEI
	    var mei;
	    var orig_mei;
	    // And the graph node in the MEI
	    var mei_graph;
	    var orig_mei_graph;
	    // This is the MEI as text (pre-parse)
	    var data;
	    var orig_data;
	    // We need a reader
	    var reader = new FileReader();
	    var filename;
	    // Did we change the MEI somehow?
	    var changes = false;
	    // Our undo stack. TODO: is this being empty the same as
	    // changes being false?
	    var undo_actions = [];

	    var redo_actions = []; //TODO, maybe?

	    var reduce_actions = [];

	    var rerendered_after_reduce = 0;

	    var non_notes_hidden = false;
	    
	    var text_input=false;

	    var shades = false;

	    var format;

	    var zoom = 1;



	    // Toggle if a thing (for now: note) is selected or not.
            function toggle_selected(item,extra) { 
	      if(selected.find(x => x === item) || extraselected.find(x => x === item)) {
		item.setAttribute("style","fill:black");
		selected = selected.filter(x =>  x !== item);
		extraselected = extraselected.filter(x =>  x !== item);
	      } else {
		if(extra) {
		  item.setAttribute("style","fill:red");
		  extraselected.push(item);
		}else {
		  item.setAttribute("style","fill:green");
		  selected.push(item);
		}
	      }
	    }
            // Get the MEI-graph nodes that are adjacent to a hyperedge
            function hyperedge_allnodes(he) {
	      var arcs_array = Array.from(mei_graph.getElementsByTagName("arc"));
	      var nodes = [];
	      arcs_array.forEach(function (a) {
		    if(a.getAttribute("from") == "#"+he.getAttribute("xml:id")){
		      nodes.push(get_by_id(mei,a.getAttribute("to")));
		    }
		  });
	      return nodes;
	    }
            // Get the MEI-graph nodes that are adjacent and primary to a hyperedge
            function hyperedge_primaries(he) {
	      var arcs_array = Array.from(mei_graph.getElementsByTagName("arc"));
	      var nodes = [];
	      arcs_array.forEach(function (a) {
		if(a.getAttribute("from") == "#"+he.getAttribute("xml:id") &&
		   a.getAttribute("type") == "primary"){
		  nodes.push(get_by_id(mei,a.getAttribute("to")));
		}
		  });
	      return nodes;
	    }
            // Get the MEI-graph nodes that are adjacent and secondary to a hyperedge
            function hyperedge_secondaries(he) {
	      var arcs_array = Array.from(mei_graph.getElementsByTagName("arc"));
	      var nodes = [];
	      arcs_array.forEach(function (a) {
		if(a.getAttribute("from") == "#"+he.getAttribute("xml:id") &&
		   a.getAttribute("type") == "secondary"){
		  nodes.push(get_by_id(mei,a.getAttribute("to")));
		}
		  });
	      return nodes;
	    }

            // This reduces away the hyperedges where all the secondaries
	    // are not primary in any non-reduced hyperedge. TODO: This is
	    // a very stupid implementation akin to bubble sort. No doubt
	    // the complexity and performance can be _greatly_ improved.
            function do_reduce() {
	      var nodes_array = Array.from(mei_graph.getElementsByTagName("node"));
	      // Get the nodes representing hyperedges
	      var hyperedges_nodes = nodes_array.filter(function(x) { return x.getAttribute("type") == "hyperedge";})
	      var remaining_hyperedges = hyperedges_nodes.filter(function(x) { 
		return reduce_actions.flat().flat().findIndex(function(y) {return y == x; }) == -1
	      });
	      var reduce_action = [];
	      // For each remaining hyperedge
	      if(remaining_hyperedges.length == 0){
		console.log("No reduction possible");
		return;
	      }

	      remaining_hyperedges.forEach(function (he) {
	        var secondaries = hyperedge_secondaries(he); 
		// If none of this hyperedges secondary nodes are such that
		if(secondaries.length > 0 && 0 == secondaries.filter(function(x) { 
		  // Any other remaining hyperedge
	 	  return 0 != remaining_hyperedges.filter( function (hf) {
		    // Has it as a primary
		    return hyperedge_primaries(hf).findIndex(function(y) {return x == y;}) != -1;
		  }).length;
		}).length){
		  // Then we can safely reduce this hyperedge
		  reduce_action.push(he);
		}
	      });
	      reduce_actions.push(reduce_action.map(function(he) {
		var secondaries = hyperedge_secondaries(he);
		var graphicals = [];
		graphicals.push(secondaries.map(hide_note));
		graphicals.push(hide_he(he));
		return [he,secondaries,graphicals];
	      }));
	    }

            function undo_reduce() {
	      if(reduce_actions.length == rerendered_after_reduce){
		console.log("Cannot undo reduce past a rerender");
		return;
	      }
	      var reduce_layer = reduce_actions.pop();
	      reduce_layer.forEach(function(action) {
		var [he,secondaries,graphicals] = action;
		graphicals.flat().forEach(function(x) { if(x) x.style.visibility = "visible";});
		secondaries.forEach(function(x) { if(x) mark_secondary(get_by_id(document,note_get_sameas(x))); });
	      });

	    }


            function hide_note(note) {
	      var elem = get_by_id(document,note_get_sameas(note));
	      if(elem)
		elem.style.visibility = "hidden";
	      return elem;
	    }

            function hide_he(he) {
	      var elem = get_by_id(document,he.getAttribute("xml:id"));
	      if(elem) 
		elem.style.visibility = "hidden";
	      return elem;
	    }

            function mark_secondary(item) {
		item.setAttribute("style","fill:grey");
	    }



            // Draw a series of edges (TODO: make it much much much better)
            function draw_edges() {
	      var added = [];
	      if(selected.findIndex(function(x) { return x == undefined; }) != -1)
		return [];
	      for(var i = 1; i < selected.length; i++) {
		note1 = note_coords(selected[i-1]);
		note2 = note_coords(selected[i]);
		//added.push(line(note1,note2));
		added.push(roundedHull([note1,note2]));
	      // TODO: Add selectability on edge.
	      }
	      return added;
	    }

            function add_mei_node_for(mei,mei_graph,note) {
	        var id = note.getAttribute("id");
		var elem = get_by_id(mei,"gn-"+id);
		if (elem != null) {
		  return elem;
		}
		elem = mei.createElement("node");
		// This node represent that note
		var label = mei.createElement("label");
		var note = mei.createElement("note");
		note.setAttribute("sameas","#"+id);
		elem.appendChild(label);
		label.appendChild(note);
		// But should have a separate XML ID
		elem.setAttribute("xml:id","gn-" + id);
		mei_graph.appendChild(elem);
		return elem;
	    }
            
            // Add a collection of edges to the MEI graph element
            function add_edges(mei) {
	      var added = [];
	      for(var i = 0; i < selected.length; i++) {
		var elem = add_mei_node_for(mei,mei_graph,selected[i]);
		added.push(elem);
	      }
	      for(var i = 1; i < selected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#gn-"+selected[i-1].getAttribute("id"));
		elem.setAttribute("to","#gn-"+selected[i].getAttribute("id"));
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      return added;
	    }

            // Draw a hyperedge as a  series of edges (TODO: make it much much much better)
            function draw_hyperedge(id,type) {
	      var added = [];
	      var notes = selected.concat(extraselected);
	      if(notes.findIndex(function(x) { return x == undefined; }) != -1) {
		console.log("Note missing, hyperedge not drawn");
		return [];
	      }

	      notes.sort(function(a,b) { 
		  var p1= note_coords(a);
		  var p2= note_coords(b);
		  return (p1[0] - p2[0]) ? (p1[0] - p2[0]) : (p1[1] - p2[1]);
		});


	      //for(var i = 1; i < notes.length; i++) {
		//note1 = note_coords(notes[i-1]);
		//note2 = note_coords(notes[i]);
		//added.push(line(note1,note2));
	        var elem = roundedHull(notes.map(note_coords));
		elem.setAttribute("id",id);
		elem.setAttribute("class","hyperedge");
		elem.setAttribute("type",type);
		if(shades)
		  toggle_shade(elem);
		added.push(elem);
	      // TODO: Add selectability on edge.
	      //}

	      return added;
	    }
            
            // Add a "hyperedge" to the MEI graph element. We model this
	    // with a new node.
            function add_hyperedge(mei,mei_graph,type,he_id_param) {
	      var added = [];
              // Add new nodes for all notes
	      for(var i = 0; i < selected.length; i++) {
		var elem = add_mei_node_for(mei,mei_graph,selected[i]);
		added.push(elem);
	      }
	      for(var i = 0; i < extraselected.length; i++) {
		var elem = add_mei_node_for(mei,mei_graph,extraselected[i]);
		added.push(elem);
	      }
	      // Add a new node for the hyperedge
	      var he_elem = mei.createElement("node");
	      he_elem.setAttribute("type","hyperedge");
	      var he_label = mei.createElement("label");
	      if(typeof type != 'undefined')
		he_label.setAttribute("type",type)
	      he_elem.appendChild(he_label);
	      // Who knows if this is enough
	      var he_id;
	      if(typeof he_id_param == 'undefined')
	        he_id = "he-"+Math.floor(Math.random() * (1 << 20)).toString(16);
	      else
		he_id = he_id_param;
	      he_elem.setAttribute("xml:id",he_id);
	      mei_graph.appendChild(he_elem);
	      added.push(he_elem);
	      for(var i = 0; i < selected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#"+he_id);
		elem.setAttribute("to","#gn-"+selected[i].getAttribute("id"));
		elem.setAttribute("type","secondary");
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      for(var i = 0; i < extraselected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#"+he_id);
		elem.setAttribute("to","#gn-"+extraselected[i].getAttribute("id"));
		elem.setAttribute("type","primary");
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      return [he_id,added];
	    }


	    // OK we've selected stuff, let's make the selection into a
	    // series of edges
	    function do_edges() {
		if (selected.length == 0 && extraselected == 0) {
		  return;}
		changes = true;
		added = [];
		added.push(draw_edges()); // Draw the edge
		added.push(add_edges(mei));  // Add it to the MEI
		if(mei != orig_mei)
		  added.push(add_edges(orig_mei));
		
		undo_actions.push([added,selected,extraselected]);
		selected.forEach(toggle_selected); // De-select
		extraselected.forEach(toggle_selected); // De-select
	    }

	    // OK we've selected stuff, let's make the selection into a
	    // "hyperedge".
	    function do_hyperedge(type) {
		if (selected.length == 0 && extraselected == 0) {
		  return;}
		changes = true;
		added = [];
		var [he_id,mei_elems] = add_hyperedge(mei,mei_graph,type);
		added.push(mei_elems);  // Add it to the MEI
		if(mei != orig_mei){
		  var [orig_he_id,orig_mei_elems] = add_hyperedge(orig_mei,orig_mei_graph,type,he_id);
		  added.push(orig_mei_elems);  // Add it to the MEI
		}
		added.push(draw_hyperedge(he_id,type)); // Draw the edge
		
		undo_actions.push([added,selected,extraselected]);
		selected.forEach(mark_secondary); // De-select
		selected = [];
		extraselected.forEach(toggle_selected); // De-select
	    }

            // Oops, undo whatever we did last.
	    function do_undo() {
		// Get latest undo_actions
	        if(undo_actions.length == 0) {
		  console.log("Nothing to undo");
		  return;
		}

		[added,sel,extra] = undo_actions.pop();
		// Deselect the current selection, if any
		selected.forEach(toggle_selected);
		extraselected.forEach(function(x) {toggle_selected(x,true);});
		// Remove added elements
		added.flat().forEach(function(x) {
		    if(!node_referred_to(x.getAttribute("xml:id")))
		      x.parentNode.removeChild(x);
		    });
		// Select last selection
		sel.forEach(function(x) {toggle_selected(x);});
		extra.forEach(function(x) {toggle_selected(x,true);});
	    }

            function toggle_shade(he) {
	      if(!shades && he.getAttribute("old_fill")){
		he.setAttribute("fill",he.getAttribute("old_fill"));
		he.removeAttribute("old_fill");
	      }else if (shades && type_shades[he.getAttribute("type")]){
		he.setAttribute("old_fill", he.getAttribute("fill"));
		he.setAttribute("fill",getRandomShade(type_shades[he.getAttribute("type")]));
	      }
	    }

            function toggle_button_shade(button) {
	      if(shades) 
		button.style.color=button_shades[button.getAttribute("id")];
	      else
		button.style.color="";
	    }


            function toggle_shades() {
	      shades = !shades;
	      Array.from(document.getElementsByClassName("hyperedge")).forEach(toggle_shade);
	      Array.from(document.getElementsByClassName("hyperedgebutton")).forEach(toggle_button_shade);
	    }

            // We have keyboard commands!
            function handle_keypress(ev) {
	      if(text_input)
		return;
	      if (ev.key == "Enter"){
		do_edges();
	      } else if (ev.key == "u") { // UNDO
		do_undo();
	      } else if (ev.key == "r") { // Reduce hyperedges
		do_reduce();
	      } else if (ev.key == "s") { // Show/hide ties etc.
		toggle_equalize();
	      } else if (ev.key == "h") { // Add a hyperedge
		do_hyperedge();
	      } else if (ev.key == "+") { // Select same notes in the measure
		select_samenote();
		do_hyperedge("repeat");
	      } else if (ev.key == "p") { // Add a hyperedge
		do_hyperedge("passing");
	      } else if (ev.key == "n") { // Add a hyperedge
		do_hyperedge("neighbour");
	      } else if (ev.key == "i") { // Add a hyperedge
		do_hyperedge("harmonic");
	      } else if (ev.key == "a") { // Add a hyperedge
		do_hyperedge("arpeggio");
	      } else if (ev.key == "u") { // Add a hyperedge
		do_hyperedge("urlinie");
	      } else if (ev.key == "b") { // Add a hyperedge
		do_hyperedge("bassbrechung");
	      }else {
		console.log(ev.key);
	      }

	    }

	    // Function to download data to a file
            // Taken from StackOverflow answer by Kanchu at
            // https://stackoverflow.com/questions/13405129/javascript-create-and-save-file
	    function download(data, filename, type) {
		var file = new Blob([data], {type: type});
		if (window.navigator.msSaveOrOpenBlob) // IE10+
		    window.navigator.msSaveOrOpenBlob(file, filename);
		else { // Others
		    var a = document.createElement("a"),
			    url = URL.createObjectURL(file);
		    a.href = url;
		    a.download = filename;
		    document.body.appendChild(a);
		    a.click();
		    setTimeout(function() {
			document.body.removeChild(a);
			window.URL.revokeObjectURL(url);  
		    }, 0); 
		}
	    }

            // If the MEI already has a graph, we add on to that. TODO:
	    // Check that the graph is actually our kind of graph
            function add_or_fetch_graph() {
	      var existing = mei.getElementsByTagName("graph");
	      if(existing.length) {
		// TODO: Not just grab the first one.
		return existing[0];
	      }
	      var elem = mei.createElement("graph");
	      elem.setAttribute("type","directed");
	      mei.getElementsByTagName("body")[0].appendChild(elem);
	      return elem;
	    }
  
            // An option to download the MEI with the changes we've made
	    function save() {
	      var saved = new XMLSerializer().serializeToString(mei);
	      download(saved, filename+".mei", "text/xml");
	    }
	    function save_orig() {
	      var saved = new XMLSerializer().serializeToString(orig_mei);
	      download(saved, filename+".mei", "text/xml");
	    }

	    // Download the current SVG, including graph elements
	    function savesvg() {
	      var saved = new XMLSerializer().serializeToString($("#svg_output")[0]);
	      download(saved, filename+".svg", "text/xml");
	    }

            // Load a new MEI
            function load() {
	      /* Cancel loading if changes are not saved? alert */
	      selected = [];
	      extraselected = [];
	      upload = document.getElementById("fileupload");
	      if(upload.files.length == 1){
		reader.addEventListener("load",load_finish);
		reader.readAsText(upload.files[0]);
		filename = upload.files[0].name.split(".").slice(0,-1).join(".");
		if(filename == "")
		  filename = upload.files[0].name;
	      }else{
		return;
	      }
	    }

            function get_by_id(doc,id) {
	      if (id[0] == "#") { id = id.slice(1); }
	      var elem =  doc.querySelector("[*|id='"+id+"']");
	      if(elem) {
		return elem;
	      }else{
		return Array.from(doc.all).find(function(x) { return x.getAttribute("id") == id || x.getAttribute("xml:id") == id; });
	      }
	    }

            function node_referred_to(id) {
	      return Array.from(mei.getElementsByTagName("arc"))
		.filter(function(x) {
		    return (x.getAttribute("from") == "#"+id || 
			    x.getAttribute("to") == "#"+id);
		 }).length > 0;
	    }

            function note_get_sameas(note) {
	      return note.getElementsByTagName("label")[0].
		          getElementsByTagName("note")[0].
		          getAttribute("sameas");
	    }




            // Draw the existing graph
            function draw_graph() {
	      // There's a multi-stage process to get all the info we
	      // need... First we get the nodes from the graph element.
	      var nodes_array = Array.from(mei_graph.getElementsByTagName("node"));
	      // Get the nodes representing hyperedges
	      var hyperedges_nodes = nodes_array.filter(function(x) { return x.getAttribute("type") == "hyperedge";})
	      // Next we get the note labels
	      var note_ids = nodes_array.map(function(x) {
		            try{
			      return [x, 
			              note_get_sameas(x)]
			    }catch{
			      return [];
			    }
			  }).filter(function(x) {return x.length != 0;});
	      // Now get the arcs/edges
	      var arcs_array = Array.from(mei_graph.getElementsByTagName("arc"));
	      var hyperedges_arcs = [];
	      // And draw them all.
	      arcs_array.forEach(function(x) {
		  var n1 = get_by_id(mei,x.getAttribute("from")); 
		  var n2 = get_by_id(mei,x.getAttribute("to"));
		  if (hyperedges_nodes.findIndex(function (x) {return x == n1;}) == -1){
		    //Regular edge, just draw. TODO: Fix assumption that
		    //nodes are notes if we reach this.
		    var id1 = note_ids.find(function(y) {
			  return y[0] == n1;
			})[1];
		    var id2 = note_ids.find(function(y) {
			  return y[0] == n2;
			})[1];
		    selected = [get_by_id(document,id1),get_by_id(document,id2) ];
		    draw_edges();
		    selected = [];
		  }else{
		    var id2 = note_ids.find(function(y) {
			  return y[0] == n2;
			})[1];
		    hyperedges_arcs.push([n1,id2,x.getAttribute("type")]);
		  }
	      });
	      hyperedges_nodes.forEach(function(x) {
		  var hyperedge_nodes = hyperedges_arcs.
		              filter(function(y) {return y[0] == x;}).
			      map(function(y) {return [y[2],get_by_id(document,y[1])];})
	          selected = hyperedge_nodes.
		              filter(function(y) {return y[0] == "secondary";}).
			      map(function (y) { return y[1];});
	          extraselected = hyperedge_nodes.
		              filter(function(y) {return y[0] == "primary";}).
			      map(function (y) { return y[1];});
	          var he_labels = x.getElementsByTagName("label");
		  var type = "";
		  if(he_labels.length > 0){
		    type = he_labels[0].getAttribute("type");
		  }
		  var added = draw_hyperedge(x.getAttribute("xml:id"),type);
		  if(added.length > 0)
		    selected.forEach(mark_secondary); // De-select
		  selected = [];
		  extraselected = [];
		});

	    }
            
            // Do all of this when we have the MEI in memory
            function load_finish(e) {
	      data = reader.result;
	      parser = new DOMParser();
	      mei = parser.parseFromString(data,"text/xml");
	      format = "mei";
	      if(mei.documentElement.namespaceURI != "http://www.music-encoding.org/ns/mei")
		// We didn't get a MEI? Try if it's a musicXML
		format = "musicxml";
	      svg = vrvToolkit.renderData(data, {pageWidth: 20000,
		  pageHeight: 10000, breaks: "none", format: format});
	      $("#svg_output").html(svg);
	      if(format == "musicxml"){
		data = vrvToolkit.getMEI();
		parser = new DOMParser();
		mei = parser.parseFromString(data,"text/xml");
	      }

	      mei_graph = add_or_fetch_graph();
	      orig_mei = mei;
	      orig_data = data;
	      orig_mei_graph = mei_graph;
	      orig_svg = svg;

	      draw_graph();

	      changes = false;
	      undo_actions = [];
	      redo_actions = []; //TODO, maybe?
	      reduce_actions = [];

	      rerendered_after_reduce = 0;

	      for (let n of document.getElementsByClassName("note")) {
		  n.addEventListener('click', function(ev) {toggle_selected(n,ev.shiftKey) } )
	      }
	      document.addEventListener('keypress',function(ev) {handle_keypress(ev);});
	    }

            function toggle_equalize() {
	      var hidden = "hidden";
	      if(non_notes_hidden){
		hidden = "visible";
		non_notes_hidden = false;
	      }else{
		non_notes_hidden = true;
	      }
	      set_non_note_visibility(hidden);
	    }

            function set_non_note_visibility(hidden) {
	      var svg_element = document.getElementById("svg_output");
	      Array.from(svg_element.getElementsByClassName("beam")).forEach(function(x)
		  { Array.from(x.children).forEach(function(x) { if(x.tagName == "polygon") { x.style.visibility= hidden; }})});
	      Array.from(svg_element.getElementsByClassName("fermata")).forEach(function(x)
		  { x.style.visibility= hidden; });
	      Array.from(svg_element.getElementsByClassName("rest")).forEach(function(x)
		  { x.style.visibility= hidden; });
	      Array.from(svg_element.getElementsByClassName("stem")).forEach(function(x)
		  { x.style.visibility= hidden; });
	      Array.from(svg_element.getElementsByClassName("flag")).forEach(function(x)
		  { x.style.visibility= hidden; });
	      Array.from(svg_element.getElementsByClassName("tie")).forEach(function(x)
		  { x.style.visibility= hidden; });
	    }




            function rerender(output) {
	      var mei2 = mei.implementation.createDocument(
		    mei.documentElement.namespaceURI, //namespace to use
		    null,             //name of the root element (or for empty document)
		    null              //doctype (null for XML)
		    );
	      var newNode = mei2.importNode(
		  mei.documentElement, //node to import
		  true                 //clone its descendants
		  );
	      mei2.appendChild(newNode);

	      Array.from(document.getElementsByClassName("note")).forEach(function(x) {
		if(x.style.visibility == "hidden"){
		  //TODO: this is wrong
		  // 
		  var y = get_by_id(mei2,x.getAttribute("id"));
		  y.parentNode.removeChild(y);
		}
	      });
	      var data2 = new XMLSerializer().serializeToString(mei2);

	      var svg2 = vrvToolkit.renderData(data2, {pageWidth: 20000,
		  pageHeight: 10000, breaks: "none", format: "mei"});

	      $("#svg_output").html(svg2);
	      svg = svg2;
	      mei = mei2;
	      data = data2;
	      mei_graph = add_or_fetch_graph();
	      for (let n of document.getElementsByClassName("note")) {
		  n.addEventListener('click', function(ev) {toggle_selected(n,ev.shiftKey) } )
	      }
	      if(non_notes_hidden)
		set_non_note_visibility("hidden");
	      // Need also to redraw edges and hyperedges
	      draw_graph();

	      // Can't undo after a rerender.. yet, TODO: Make layers
	      rerendered_after_reduce=reduce_actions.length;
	      reduce_actions = [];
	      // This is one of the ugliest hacks I've made I think
	      for(var i = 0; i < rerendered_after_reduce; i++)
		do_reduce();
	      undo_action = [];

	    }

            function rerender_temp() {
	      rerender(document.getElementById("svg_output2"));
	    }

	    function get_measure(elem) {if(elem.tagName == "measure") return elem; else return get_measure(elem.parentElement);}

            function select_samenote() {
	      if((selected.length == 1 || extraselected.length == 1)
	       && !(selected.length == 1 &&  extraselected.length == 1)){
		var svg_note;
		if(selected.length == 1)
		  svg_note = selected[0];
		else
		  svg_note = extraselected[0];
		var note = get_by_id(mei,svg_note.getAttribute("id"));
		var measure = get_measure(note);
		var candidates = Array.from(measure.getElementsByTagName("note"));
		candidates.forEach(function(x) { if(
			      x.getAttribute("oct") == note.getAttribute("oct") &&
			      x.getAttribute("pname") == note.getAttribute("pname")) {
		      toggle_selected(get_by_id(document,x.getAttribute("xml:id")));
		    }
		    });
		//This is an ugly hack
		toggle_selected(svg_note,true);
	      }
	    }

            function texton() { text_input = true; }
            function textoff() { text_input = false; }
	    function show_buttons() {
	      $("#load_save")[0].style.display="";
	      $("#hidden_buttons")[0].style.display="none";
	    }
	    function hide_buttons() {
	      $("#load_save")[0].style.display="none";
	      $("#hidden_buttons")[0].style.display="";
	    }

            function zoom_in() {
	      zoom += 0.1;
	      $("#svg_output")[0].style.transform="scale("+zoom+")";
	    }
            function zoom_out() {
	      zoom -= 0.1;
	      $("#svg_output")[0].style.transform="scale("+zoom+")";
	    }




        </script>
	<div id="hidden_buttons" style="position:fixed; z-index:2">
	<input type=button id="showbutton" value="Show" onclick="show_buttons()">
	</div>
	<div id="load_save" style="position:fixed; z-index:2">
	  <input type="button" id="hidebutton" value="Hide" onclick="hide_buttons()">
	  <input type="file" id="fileupload" value="Load" onchange="load()" >
	  <!--input type="button" id="uploadbutton" value="Load" onclick="load()" -->
	  <!--input type="button" id="downloadbutton" value="Save" onclick="save()" -->
	  <input type="button" id="downloadbutton" value="Save" onclick="save_orig()" >
	  <input type="button" id="svgdownloadbutton" value="Save SVG" onclick="savesvg()" >
	  <input type="button" id="reducebutton" value="Reduce Hyperedges" onclick="do_reduce()" >
	  <input type="button" id="unreducebutton" value="Undo reduction" onclick="undo_reduce()" >
	  <input type="button" id="equalizebutton" value="Toggle stems etc." onclick="toggle_equalize()" >
	  <input type="button" id="shadesbutton" value="Toggle type-dependent shades." onclick="toggle_shades()" >
	  <input type="button" id="rerenderbutton" value="Rerender less hidden notes" onclick="rerender_temp()" >
	  <input type="button" id="selectifybutton" value="Select similar notes" onclick="select_samenote()" > <br/>
	  <input type="button" id="undobutton" value="Undo" onclick="do_undo()" >
	  <input type="button" id="edgebutton" value="Add untyped edges" onclick="do_edges()" >
	  <input type="button" id="hyperedgebutton" value="Add untyped hyperedge" onclick="do_hyperedge()" > 
	  <input type="button" id="customhyperedgebutton" value="Add hyperedge with custom type:" onclick="do_hyperedge($('#custom_type')[0].value)" >
	  <input type="text" id="custom_type" onfocus="texton()" onblur="textoff()">
	  <div id="simple_buttons">
	  <input type="button" class="hyperedgebutton" id="repeathyperedgebutton" value="Add repeat hyperedge" onclick="do_hyperedge('repeat')" >
	  <input type="button" class="hyperedgebutton" id="passinghyperedgebutton" value="Add passing hyperedge" onclick="do_hyperedge('passing')" >
	  <input type="button" class="hyperedgebutton" id="neighbourhyperedgebutton" value="Add neighbour hyperedge" onclick="do_hyperedge('neighbour')" >
	  <input type="button" class="hyperedgebutton" id="harmonichyperedgebutton" value="Add harmonic hyperedge" onclick="do_hyperedge('harmonic')" >
	  <input type="button" class="hyperedgebutton" id="arpeggiohyperedgebutton" value="Add arpeggio hyperedge" onclick="do_hyperedge('arpeggio')" >
	  </div>
	  <div id="schenker buttons">
	  <input type="button" class="hyperedgebutton" id="urliniehyperedgebutton" value="Add urlinie hyperedge" onclick="do_hyperedge('urlinie')" >
	  <input type="button" class="hyperedgebutton" id="bassbrechunghyperedgebutton" value="Add bassbrechung hyperedge" onclick="do_hyperedge('bassbrechung')" >
	  </div>

	</div>
	<div id="zoom buttons" style="position:fixed; top:0; right:0; z-index:2">
	<input type="button" class="zoombutton" value="+" onclick="zoom_in()"><br/>
	<input type="button" class="zoombutton" value="-" onclick="zoom_out()"><br/>
	</div>


        <!--//////////////////////////////////////////////-->
        <!-- The div where we are going to insert the SVG -->
        <!--//////////////////////////////////////////////-->
	
	<div style="transform-origin: top left; z-index:-1" id="svg_output"></div>



    </body>
</html>
