<html>
    <head>
        <title>DCML Reductive Analysis Webapp / Redusic / MuseReduce /</title>
        <!--/////////////////////-->
        <!-- The Verovio toolkit -->
        <!--/////////////////////-->
        <script src="js/verovio-toolkit.js" type="text/javascript" ></script>
        <!--////////////////////-->
        <!-- We also use jQuery -->
        <!--////////////////////-->
        <script src="https://code.jquery.com/jquery-3.1.1.min.js" type="text/javascript" ></script>
        <!--/////////////////////-->
        <!-- And D3JS            -->
        <!--/////////////////////-->
        <script src="js/d3.min.js" type="text/javascript" ></script>
	<script src="js/utils.js" type="text/javascript"></script>
	<script src="js/conf.js" type="text/javascript"></script>
	<link type="text/css" rel="stylesheet" href="css/style.css" >
    </head>
    <body>
	<svg width="0" height="0" style="display:block;">
	  <filter id="glowFilter">
	    <feFlood result="flood" flood-color="#444444"/>
	    <feComposite in="flood" in2="SourceGraphic" operator="in" result="mask"/>
	    <feMorphology in="mask" operator="dilate" radius="2" result="thickened"/>
	    <feGaussianBlur in="thickened" stdDeviation="5" result="coloredBlur"/>
	    <feMerge>
	      <feMergeNode in="coloredBlur"/>
	      <feMergeNode in="SourceGraphic"/>
	    </feMerge>
	  </filter>
	  <filter id="selectFilter">
	    <feFlood result="flood" flood-color="#00ff00"/>
	    <feComposite in="flood" in2="SourceGraphic" operator="in" result="mask"/>
	    <feMorphology in="mask" operator="dilate" radius="2" result="thickened"/>
	    <feGaussianBlur in="thickened" stdDeviation="5" result="coloredBlur"/>
	    <feMerge>
	      <feMergeNode in="coloredBlur"/>
	      <feMergeNode in="SourceGraphic"/>
	    </feMerge>
	  </filter>
	  <filter id="extraFilter">
	    <feFlood result="flood" flood-color="#ff0000"/>
	    <feComposite in="flood" in2="SourceGraphic" operator="in" result="mask"/>
	    <feMorphology in="mask" operator="dilate" radius="2" result="thickened"/>
	    <feGaussianBlur in="thickened" stdDeviation="5" result="coloredBlur"/>
	    <feMerge>
	      <feMergeNode in="coloredBlur"/>
	      <feMergeNode in="SourceGraphic"/>
	    </feMerge>
	  </filter>
	</svg>

        <script type="text/javascript">
	    // GLOBALS
	    // Clicking selects
            var selected = [];
	    // Shift-clicking extra selects
            var extraselected = [];
	    // Load Verovio
            var vrvToolkit = new verovio.toolkit();
	    // This is our SVG
	    var svg;
	    var orig_svg;
	    // And the underlying MEI
	    var mei;
	    var orig_mei;
	    // And the graph node in the MEI
	    var mei_graph;
	    var orig_mei_graph;
	    // This is the MEI as text (pre-parse)
	    var data;
	    var orig_data;
	    // We need a reader
	    var reader = new FileReader();
	    var filename;
	    // Did we change the MEI somehow?
	    var changes = false;
	    // Our undo stack. TODO: is this being empty the same as
	    // changes being false?
	    var undo_actions = [];

	    var redo_actions = []; //TODO, maybe?


	    var rerendered_after_reduce = 0;

	    var non_notes_hidden = false;
	    
	    var text_input=false;

	    var shades = false;

	    var format;

	    var zoom = 1;

	    // Once things are loaded, do configuration stuff
	    $(document).ready(function()
		{
		  Object.keys(type_conf).forEach(init_type);
		  toggle_shades();
		});

            // Configured types need a button and a color each
            function init_type(type) {
	      var elem = document.createElement("input");
	      elem.setAttribute("type","button");
	      elem.setAttribute("class","hyperedgebutton");
	      elem.setAttribute("id",type + "hyperedgebutton");
	      elem.setAttribute("value","Add "+type+" hyperedge " + "(" + type_conf[type].key + ")");
	      elem.onclick = () => {do_hyperedge(type);};
	      $("#relation_buttons")[0].appendChild(elem);
	      type_shades[type] = shades_array[type_conf[type].colour];
	      type_keys[type_conf[type].key] = type;
	      button_shades[type+"hyperedgebutton"] = shades_array[type_conf[type].colour];
	    }

            // If we're selecting hyperedges, we may want to change them.
            function toggle_he_selected(selecting) {
	      Array.from(document.getElementsByClassName("hyperedgebutton")).forEach((button) => {
		    var val = button.getAttribute("value");
		    if(selecting)
		      button.setAttribute("value",val.replace("Add","Set to"));
		    else
		      button.setAttribute("value",val.replace("Set to","Add"));
              });
	    }

	    // Toggle if a thing (for now: note or hyperedge) is selected or not.
            function toggle_selected(item,extra) { 
	      var ci = item.getAttribute("class");
	      if(selected.length > 0 || extraselected.length > 0) {
		var csel = selected.concat(extraselected)[0].getAttribute("class");
		// Select only things of the same type for now - editing
		// hyperedges to add things means deleting and re-adding
		if(ci != csel)
		  return;
	      }
	      if(ci == "note"){
		// We're selecting notes.
		if(selected.find(x => x === item) || extraselected.find(x => x === item)) {
		  item.style.fill = "black";
		  selected = selected.filter(x =>  x !== item);
		  extraselected = extraselected.filter(x =>  x !== item);
		} else {
		  if(extra) {
		    item.style.fill="red";
		    extraselected.push(item);
		  }else {
		    item.style.fill ="green";
		    selected.push(item);
		  }
		}
	      } else if(ci == "hyperedge" || ci == "metaedge"){
		//Hyperedge selection
		if(selected.concat(extraselected).length == 0){
		  // We're beginning to select hyperedges
		  toggle_he_selected(true);
		}
		if(selected.find(x => x === item) || extraselected.find(x => x === item)) {
		  item.style.fillOpacity = 0.5;
		  item.style.strokeOpacity = 0.1;
		  selected = selected.filter(x =>  x !== item);
		  extraselected = extraselected.filter(x =>  x !== item);
		  item.style.transform = "";
		  item.style.filter = "";
		} else {
		  if(extra){
		    item.style.fillOpacity = 0.9;
		    item.style.strokeOpacity = 0.8;
		    extraselected.push(item);
		    item.style.transform = "translate3d(0,0,0)";
		    item.style.filter = "url(\"#extraFilter\")";
		  }else{
		    item.style.fillOpacity = 0.9;
		    item.style.strokeOpacity = 0.8;
		    selected.push(item);
		    item.style.transform = "translate3d(0,0,0)";
		    item.style.filter = "url(\"#selectFilter\")";
		  }
		}
		if(selected.concat(extraselected).length == 0){
		  // We're finished selecting hyperedges
		  toggle_he_selected(false);
		}
	      }
	      var primaries = to_text(extraselected);
	      var secondaries = to_text(selected);
	      $("#selected_things").html("Primaries: "+primaries+"<br/>Secondaries: "+secondaries);  

	    }

            // Toggle showing things other than notes in the score
            function toggle_equalize() {
	      var hidden = "hidden";
	      if(non_notes_hidden){
		hidden = "visible";
		non_notes_hidden = false;
	      }else{
		non_notes_hidden = true;
	      }
	      set_non_note_visibility(hidden);
	    }

            function set_non_note_visibility(hidden) {
	      var svg_element = document.getElementById("svg_output");
	      Array.from(svg_element.getElementsByClassName("beam")).forEach((x) =>
		  { Array.from(x.children).forEach((x) => { if(x.tagName == "polygon") { x.style.visibility= hidden; }})});
	      hide_classes.forEach((cl) => {
		Array.from(svg_element.getElementsByClassName(cl)).forEach((x) =>
		    { x.style.visibility= hidden; });
	      })
	    }


            // Toggle the current hyperedge having a type-dependent shade
	    // or not
            function toggle_shade(he) {
	      if(!shades && he.getAttribute("old_fill")){
		he.setAttribute("fill",he.getAttribute("old_fill"));
		he.removeAttribute("old_fill");
	      }else if (shades && type_shades[he.getAttribute("type")]){
		he.setAttribute("old_fill", he.getAttribute("fill"));
		he.setAttribute("fill",type_shades[he.getAttribute("type")]);
	      }else if (shades && type_synonym[he.getAttribute("type")]){
		he.setAttribute("old_fill", he.getAttribute("fill"));
		he.setAttribute("fill",type_shades[type_synonym[he.getAttribute("type")]]);
	      }
	    }

            function toggle_button_shade(button) {
	      if(shades) 
		button.style.color=button_shades[button.getAttribute("id")];
	      else
		button.style.color="";
	    }

            // Toggle type-dependent shades for hyperedges and buttons
            function toggle_shades() {
	      shades = !shades;
	      Array.from(document.getElementsByClassName("hyperedge")).forEach(toggle_shade);
	      Array.from(document.getElementsByClassName("hyperedgebutton")).forEach(toggle_button_shade);
	    }

            function delete_hyperedge(elem) {
	      //Assume no meta-edges for now, meaning we only have to
	      //remove the SVG elem, the MEI node, and any involved arcs
	      var orig_mei_he,mei_he = get_by_id(mei,elem.id);
	      unmark_secondaries(mei_he);
	      
	      var orig_arcs,arcs =
		Array.from(mei.getElementsByTagName("arc")).filter((arc) =>
		  {
		   return arc.getAttribute("to") == "#"+elem.id ||
		          arc.getAttribute("from") == "#"+elem.id;
	          });
	      if(mei != orig_mei){
		orig_mei_he = get_by_id(mei,selected[0].id);
		orig_arcs =
		  Array.from(mei.getElementsByTagName("arc")).filter((arc) =>
		    {
		     return arc.getAttribute("to") == "#"+elem.id ||
			    arc.getAttribute("from") == "#"+elem.id;
		    });
	      }
	      var removed = arcs.concat(orig_arcs).concat([elem,mei_he,orig_mei_he]);
	      var action_removed = removed.map((x) => {if(x != undefined){
		  var elems = [x,x.parentElement,x.nextSibling]; 
		  x.parentElement.removeChild(x);
		  return elems;
		  }});

	      return action_removed.reverse();
	    }

	    function delete_hyperedges() {
	      if(selected.length == 0 || selected[0].getAttribute("class") != "hyperedge"){
		console.log("No hyperedge selected!");
		return;
	      }
	      var removed = selected.flatMap(delete_hyperedge);
	      undo_actions.push(["delete hyperedge",removed,selected,[]]);
	      selected = [];
	    }


            // This reduces away the hyperedges where all the secondaries
	    // are not primary in any non-reduced hyperedge. TODO: This, 
            // while better than before, no doubt has room for optimisation
            function do_reduce() {
	      // All previous reductions
	      var reduce_actions = undo_actions.filter((x) => x[0] == "reduce").map((x) => x[1]); 
	      // All hyperedges in the graph
	      var all_hyperedges_nodes = Array.from(mei_graph.getElementsByTagName("node")).filter((x) => { return x.getAttribute("type") == "hyperedge";}) 
	      // Remove the hyperedges that have been removed in previous
	      // reductions
	      var remaining_hyperedges = all_hyperedges_nodes.filter((x) => { 
		return !reduce_actions.flat().flat().includes(x);
	      });
	      var reduce_action, hyperedges_nodes;
	      // Are we doing a full reduction, or have we selected some
	      // hyperedges?
	      if(selected.length > 0 && selected[0].getAttribute("class") == "hyperedge"){
		hyperedges_nodes = selected.map((elem) => get_by_id(mei,elem.id));
	      }else {
		hyperedges_nodes = remaining_hyperedges;
	      }
	      // In any case, remember what's selected, and unselect it
	      var sel = selected;
	      var extra = extraselected;
	      sel.concat(extra).forEach(toggle_selected);
	      // No primary of a remaining hyperedge is removed in this
	      // reduction
	      var remaining_nodes = remaining_hyperedges.map(hyperedge_primaries).flat();
	      // We know that the remaining hyperedges that have not been
	      // selected for reduction will remain
	      remaining_hyperedges = remaining_hyperedges.filter((x) => {return !hyperedges_nodes.includes(x);});
	      // So all of their nodes should be added to the remaining
	      // nodes, not just the primaries
	      remaining_nodes = remaining_nodes.concat(remaining_hyperedges.map(hyperedge_secondaries).flat());

              do {
		// We want to find more hyperedges that we know need to stay 
		var more_remains = hyperedges_nodes.filter((he) => { 
		    // That is, hyperedges that have, as secondaries, nodes
		    // we know need to stay
		    return (hyperedge_secondaries(he).findIndex((x) => {return remaining_nodes.includes(x);}) > -1);
		  });
		// Add those hyperedges to the ones that need to stay
		remaining_hyperedges = remaining_hyperedges.concat(more_remains);
		// And remove them from those that may be removed
		hyperedges_nodes = hyperedges_nodes.filter((x) => {return !more_remains.includes(x);})
		// And update the remaining nodes
		remaining_nodes = remaining_nodes.concat(more_remains.map(hyperedge_secondaries).flat());
	      // Until we reach a pass where we don't find any more
	      // hyperedges that need to stay
	      }while(more_remains.length > 0)
	      // Any hyperedges that remain after this loop, we can remove,
	      // including their secondaries

	      reduce_action = hyperedges_nodes;

	      if(reduce_action.length == 0){
		console.log("No reduction possible");
		return;
	      }
	      undo_actions.push(["reduce", reduce_action.map((he) => {
		var secondaries = hyperedge_secondaries(he);
		var graphicals = [];
		graphicals.push(secondaries.map(hide_note));
		graphicals.push(hide_he(he));
		return [he,secondaries,graphicals];
	      }),sel, extra]);
	    }



            // Draw a series of edges (TODO: make it much much much better)
            function draw_edges() {
	      var added = [];
	      if(selected.includes(undefined));
		return [];
	      for(var i = 1; i < selected.length; i++) {
		note1 = note_coords(selected[i-1]);
		note2 = note_coords(selected[i]);
		//added.push(line(note1,note2));
		var elem = roundedHull([note1,note2]);
		add_to_svg_bg(elem);
		added.push(elem);
	      // TODO: Add selectability on edge.
	      }
	      return added;
	    }

            // Add a collection of edges to the MEI graph element
            function add_edges(mei) {
	      var added = [];
	      for(var i = 0; i < selected.length; i++) {
		var elem = add_mei_node_for(mei,mei_graph,selected[i]);
		added.push(elem);
	      }
	      for(var i = 1; i < selected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#gn-"+selected[i-1].getAttribute("id"));
		elem.setAttribute("to","#gn-"+selected[i].getAttribute("id"));
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      return added;
	    }

            // Draw a hyperedge as a  series of edges (TODO: make it much much much better)
            function draw_hyperedge(id,type) {
	      var added = [];
	      var notes = selected.concat(extraselected);
	      if(notes.includes(undefined)) {
		console.log("Note missing, hyperedge not drawn");
		return [];
	      }

	      notes.sort((a,b) => { 
		  var p1= note_coords(a);
		  var p2= note_coords(b);
		  return (p1[0] - p2[0]) ? (p1[0] - p2[0]) : (p1[1] - p2[1]);
		});


	      var elem = roundedHull(notes.map(note_coords));
	      elem.setAttribute("id",id);
	      elem.setAttribute("class","hyperedge");
	      elem.setAttribute("type",type);
	      elem.style.fillOpacity = "0.5";
	      elem.onwheel = (e) => {
		var elem1 = e.target;
		var paren = elem1.parentElement;
		paren.removeChild(elem1);
		paren.insertBefore(elem1,paren.children[0]);
		return false;
	      };
	      if(shades)
		toggle_shade(elem);
	      add_to_svg_bg(elem);
	      added.push(elem);
	      elem.onclick = function(ev) {toggle_selected(elem,ev.shiftKey);};

	      return added;
	    }
            
            // Add a "hyperedge" to the MEI graph element. We model this
	    // with a new node.
            function add_hyperedge(mei,mei_graph,type,he_id_param) {
	      var added = [];
              // Add new nodes for all notes
	      for(var i = 0; i < selected.length; i++) {
		var elem = add_mei_node_for(mei,mei_graph,selected[i]);
		added.push(elem);
	      }
	      for(var i = 0; i < extraselected.length; i++) {
		var elem = add_mei_node_for(mei,mei_graph,extraselected[i]);
		added.push(elem);
	      }
	      // Add a new node for the hyperedge
	      var he_elem = mei.createElement("node");
	      he_elem.setAttribute("type","hyperedge");
	      var he_label = mei.createElement("label");
	      if(typeof type != 'undefined')
		he_label.setAttribute("type",type)
	      he_elem.appendChild(he_label);
	      // Who knows if this is enough
	      var he_id;
	      if(typeof he_id_param == 'undefined')
	        he_id = "he-"+Math.floor(Math.random() * (1 << 20)).toString(16);
	      else
		he_id = he_id_param;
	      he_elem.setAttribute("xml:id",he_id);
	      mei_graph.appendChild(he_elem);
	      added.push(he_elem);
	      for(var i = 0; i < selected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#"+he_id);
		elem.setAttribute("to","#gn-"+selected[i].id);
		elem.setAttribute("type","secondary");
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      for(var i = 0; i < extraselected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#"+he_id);
		elem.setAttribute("to","#gn-"+extraselected[i].id);
		elem.setAttribute("type","primary");
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      return [he_id,added];
	    }


	    // OK we've selected stuff, let's make the selection into a
	    // series of edges
	    function do_edges() {
		if (selected.length == 0 && extraselected == 0) {
		  return;}
		changes = true;
		var added = [];
		added.push(draw_edges()); // Draw the edge
		added.push(add_edges(mei));  // Add it to the MEI
		if(mei != orig_mei)
		  added.push(add_edges(orig_mei));
		
		undo_actions.push(["edges",added,selected,extraselected]);
		selected.forEach(toggle_selected); // De-select
		extraselected.forEach(toggle_selected); // De-select
	    }

	    // OK we've selected stuff, let's make the selection into a
	    // "hyperedge".
	    function do_hyperedge(type) {
		if (selected.length == 0 && extraselected == 0) {
		  return;}
		changes = true;
		if(selected.concat(extraselected)[0].getAttribute("class") == "hyperedge"){
		  var types = [];
		  selected.concat(extraselected).forEach((he) => {
		      //TODO: move type_synonym application so that this
		      //is the right type == the one from the MEI
		      types.push([he.getAttribute("type"),type]);
		      he.setAttribute("type",type);
		      var mei_he = get_by_id(mei,he.id);
		      mei_he.getElementsByTagName("label")[0].setAttribute("type",type);
		      toggle_shade(he);
		  });
		  undo_actions.push(["change hyperedge type",types.reverse(),selected,extraselected]);
		}else if(selected.concat(extraselected)[0].getAttribute("class") == "note"){
		  var added = [];
		  var [he_id,mei_elems] = add_hyperedge(mei,mei_graph,type);
		  added.push(mei_elems);  // Add it to the MEI
		  if(mei != orig_mei){
		    var [orig_he_id,orig_mei_elems] = add_hyperedge(orig_mei,orig_mei_graph,type,he_id);
		    added.push(orig_mei_elems);  // Add it to the MEI
		  }
		  added.push(draw_hyperedge(he_id,type)); // Draw the edge
		  
		  undo_actions.push(["hyperedge",added,selected,extraselected]);
		  mark_secondaries(get_by_id(mei,he_id));
		  selected.concat(extraselected).forEach(toggle_selected); // De-select
		}
	    }

            function draw_metaedge(id,type) {
	      var added = [];
	      var targets =selected.concat(extraselected); 
	      var coords = targets.map(get_metaedge_target);
	      var x = average(coords.map((e) => e[0]));
	      // Above
	      var y =
		targets.concat([document.getElementsByClassName("system")[0]]).map((b) => b.getBBox().y).sort((a,b) => a > b)[0] - 500;

//	      coords.push([x,y]);
	      var g_elem = g();
//	      var elem = roundedHull(coords);
	      g_elem.setAttribute("id",id);
	      g_elem.setAttribute("class","metaedge");
	      g_elem.setAttribute("type",type);
	      g_elem.style.fillOpacity = "0.5";
	      g_elem.style.strokeOpacity = "0.1";
	      g_elem.onwheel = (e) => {
		var elem1 = e.target;
		var paren = elem1.parentElement;
		paren.removeChild(elem1);
		paren.insertBefore(elem1,paren.children[0]);
		return false;
	      };
	      coords.forEach((crds) => { var line_elem = line([x,y],crds);
		  g_elem.appendChild(line_elem);});
	      g_elem.appendChild(circle([x,y],200));
	      if(shades)
		toggle_shade(g_elem);
	      add_to_svg_bg(g_elem);
	      added.push(g_elem);
	      g_elem.onclick = function(ev) {toggle_selected(g_elem,ev.shiftKey);};
	      g_elem.onmouseover = function (ev) {

		targets.forEach((item) => {
		    if(item.style.filter == ""){
		      item.style.transform = "translate3d(0,0,0)";
		      item.style.filter = "url(\"#glowFilter\")";
		      }});
	      }
	      g_elem.onmouseout = function (ev) {
		targets.forEach((item) => {
		    if(item.style.filter == "url(\"#glowFilter\")") {
		      item.style.transform = "";
		      item.style.filter = "";
		    }});
	      }
	      return added;
	      

	    }

            function add_metaedge(type,he_id_param) {
	      // Add a new node for the hyperedge
	      var added = [];
	      var he_elem = mei.createElement("node");
	      he_elem.setAttribute("type","metaedge");
	      var he_label = mei.createElement("label");
	      if(typeof type != 'undefined')
		he_label.setAttribute("type",type)
	      he_elem.appendChild(he_label);
	      // Who knows if this is enough
	      var he_id;
	      if(typeof he_id_param == 'undefined')
	        he_id = "he-"+Math.floor(Math.random() * (1 << 20)).toString(16);
	      else
		he_id = he_id_param;
	      he_elem.setAttribute("xml:id",he_id);
	      mei_graph.appendChild(he_elem);
	      added.push(he_elem);
	      for(var i = 0; i < selected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#"+he_id);
		elem.setAttribute("to","#"+selected[i].id);
		elem.setAttribute("type","secondary");
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      for(var i = 0; i < extraselected.length; i++) {
		// So that we can refer to the node (not the note) ID in
		// arcs/edges
		var elem = mei.createElement("arc");
		elem.setAttribute("from","#"+he_id);
		elem.setAttribute("to","#"+extraselected[i].id);
		elem.setAttribute("type","primary");
		mei_graph.appendChild(elem);
		added.push(elem);
	      }
	      return [he_id,added];
	    }

            function do_metaedge(type) {
		if (selected.length == 0 && extraselected == 0) {
		  return;}
		var ci =selected.concat(extraselected)[0].getAttribute("class"); 
		if(!(ci == "hyperedge" || ci == "metaedge")){
		  return; }
		changes = true;
		var added = [];
		var [he_id,mei_elems] = add_metaedge(type);
		added.push(mei_elems);  // Add it to the MEI
		if(mei != orig_mei){
		  var [orig_he_id,orig_mei_elems] = add_metaedge(orig_mei,orig_mei_graph,type,he_id);
		  added.push(orig_mei_elems);  // Add it to the MEI
		}
		added.push(draw_metaedge(he_id,type)); // Draw the edge
		
		undo_actions.push(["metaedge",added,selected,extraselected]);
		selected.concat(extraselected).forEach(toggle_selected); // De-select
	    }


            // Oops, undo whatever we did last.
	    function do_undo() {
		// Get latest undo_actions
	        if(undo_actions.length == 0) {
		  console.log("Nothing to undo");
		  return;
		}
		if(undo_actions.length == rerendered_after_action){
		  console.log("Cannot undo past a rerender");
		  return;
		}
		// Deselect the current selection, if any
		selected.forEach(toggle_selected);
		extraselected.forEach((x) => {toggle_selected(x,true);});

		[what,elems,sel,extra] = undo_actions.pop();
		if(what == "edges" || what == "hyperedge") {
		  var added = elems;
		  if(what == "hyperedge")
		    added.flat().forEach((x) => { 
	              if(mei.contains(x) && x.getAttribute("type") == "hyperedge")
			unmark_secondaries(x);
		      });
		  // Remove added elements
		  added.flat().forEach((x) => {
		      if(!node_referred_to(x.getAttribute("xml:id")))
			x.parentNode.removeChild(x);
		      });
		  // Select last selection
		  sel.forEach((x) => {toggle_selected(x);});
		  extra.forEach((x) => {toggle_selected(x,true);});
		}else if( what == "delete hyperedge" ) {
		  var removed = elems;
		  removed.forEach((x) => {if(x) x[1].insertBefore(x[0],x[2])})
		  selected = sel;
		  selected.forEach(mark_secondaries);
		}else if (what == "change hyperedge type") {
		  var types = elems;
		  sel.concat(extra).forEach((he) => {
		      //TODO: move type_synonym application so that this
		      //is the right type == the one from the MEI
		      var [from,to] = types.pop();
		      he.setAttribute("type",from);
		      var mei_he = get_by_id(mei,he.id);
		      mei_he.getElementsByTagName("label")[0].setAttribute("type",from);
		      toggle_shade(he);
		  });
		  sel.forEach((x) => {toggle_selected(x);});
		  extra.forEach((x) => {toggle_selected(x,true);});
		}else if (what == "reduce") {
		  var reduce_layer = elems;
		  reduce_layer.forEach((action) => {
		    var [he,secondaries,graphicals] = action;
		    graphicals.flat().forEach((x) => { if(x) x.style.visibility = "visible";});
		  });
		  sel.forEach((x) => {toggle_selected(x);});
		  extra.forEach((x) => {toggle_selected(x,true);});
		}


	    }


            // We have keyboard commands!
            function handle_keypress(ev) {
	      if(text_input)
		return;
	      if (ev.key == "Enter"){
		do_edges();
	      } else if (ev.key == "u") { // UNDO
		do_undo();
	      } else if (ev.key == "r") { // Reduce hyperedges
		do_reduce();
	      } else if (ev.key == "s") { // Show/hide ties etc.
		toggle_equalize();
	      } else if (ev.key == "h") { // Toggle type-dependent shades
		toggle_shades();
	      } else if (ev.key == "+") { // Select same notes in the measure
		select_samenote();
		do_hyperedge("repeat");
	      } else if (type_keys[ev.key]) { // Add a hyperedge
		do_hyperedge(type_keys[ev.key]);
	      }else {
		console.log(ev);
	      }
	    }

	    // Function to download data to a file
            // Taken from StackOverflow answer by Kanchu at
            // https://stackoverflow.com/questions/13405129/javascript-create-and-save-file
	    function download(data, filename, type) {
		var file = new Blob([data], {type: type});
		if (window.navigator.msSaveOrOpenBlob) // IE10+
		    window.navigator.msSaveOrOpenBlob(file, filename);
		else { // Others
		    var a = document.createElement("a"),
			    url = URL.createObjectURL(file);
		    a.href = url;
		    a.download = filename;
		    document.body.appendChild(a);
		    a.click();
		    setTimeout(() => {
			document.body.removeChild(a);
			window.URL.revokeObjectURL(url);  
		    }, 0); 
		}
	    }

            // If the MEI already has a graph, we add on to that. TODO:
	    // Check that the graph is actually our kind of graph
            function add_or_fetch_graph() {
	      var existing = mei.getElementsByTagName("graph");
	      if(existing.length) {
		// TODO: Not just grab the first one.
		return existing[0];
	      }
	      var elem = mei.createElement("graph");
	      elem.setAttribute("type","directed");
	      mei.getElementsByTagName("body")[0].appendChild(elem);
	      return elem;
	    }
  
            // An option to download the MEI with the changes we've made
	    function save() {
	      var saved = new XMLSerializer().serializeToString(mei);
	      download(saved, filename+".mei", "text/xml");
	    }
	    function save_orig() {
	      var saved = new XMLSerializer().serializeToString(orig_mei);
	      download(saved, filename+".mei", "text/xml");
	    }

	    // Download the current SVG, including graph elements
	    function savesvg() {
	      var saved = new XMLSerializer().serializeToString($("#svg_output")[0]);
	      download(saved, filename+".svg", "text/xml");
	    }

            // Load a new MEI
            function load() {
	      /* Cancel loading if changes are not saved? alert */
	      selected = [];
	      extraselected = [];
	      upload = document.getElementById("fileupload");
	      if(upload.files.length == 1){
		reader.onload = load_finish;
		reader.readAsText(upload.files[0]);
		filename = upload.files[0].name.split(".").slice(0,-1).join(".");
		if(filename == "")
		  filename = upload.files[0].name;
	      }else{
		return;
	      }
	    }


            // Draw the existing graph
            function draw_graph() {
	      // There's a multi-stage process to get all the info we
	      // need... First we get the nodes from the graph element.
	      var nodes_array = Array.from(mei_graph.getElementsByTagName("node"));
	      // Get the nodes representing hyperedges
	      var hyperedges_nodes = nodes_array.filter((x) => { return x.getAttribute("type") == "hyperedge";})
	      // Get the nodes representing metaedges
	      var metaedges_nodes = nodes_array.filter((x) => { return x.getAttribute("type") == "metaedge";})
	      // Next we get the note labels
	      var note_ids = nodes_array.map((x) => {
		            try{
			      return [x, 
			              note_get_sameas(x)]
			    }catch{
			      return [];
			    }
			  }).filter((x) => {return x.length != 0;});
	      // Now get the arcs/edges
	      var arcs_array = Array.from(mei_graph.getElementsByTagName("arc"));
	      var hyperedges_arcs = [];
	      var metaedges_arcs = [];
	      // And draw them all.
	      arcs_array.forEach((x) => {
		  var n1 = get_by_id(mei,x.getAttribute("from")); 
		  var n2 = get_by_id(mei,x.getAttribute("to"));
		  if (!hyperedges_nodes.includes(n1) && !metaedges_nodes.includes(n1)){
		    //Regular edge, just draw. TODO: Fix assumption that
		    //nodes are notes if we reach this.
		    var id1 = note_ids.find((y) => {
			  return y[0] == n1;
			})[1];
		    var id2 = note_ids.find((y) => {
			  return y[0] == n2;
			})[1];
		    selected = [get_by_id(document,id1),get_by_id(document,id2) ];
		    draw_edges();
		    selected = [];
		  }else if (!metaedges_nodes.includes(n1)){
		    var id2 = note_ids.find((y) => {
			  return y[0] == n2;
			})[1];
		    hyperedges_arcs.push([n1,id2,x.getAttribute("type")]);
		  }else {
		    metaedges_arcs.push([n1,n2.getAttribute("xml:id"),x.getAttribute("type")]);
		  }

	      });
	      hyperedges_nodes.forEach((x) => {
		  var hyperedge_nodes = hyperedges_arcs.
		              filter((y) => {return y[0] == x;}).
			      map((y) => {return [y[2],get_by_id(document,y[1])];})
	          selected = hyperedge_nodes.
		              filter((y) => {return y[0] == "secondary";}).
			      map((y) => { return y[1];});
	          extraselected = hyperedge_nodes.
		              filter((y) => {return y[0] == "primary";}).
			      map((y) => { return y[1];});
	          var he_labels = x.getElementsByTagName("label");
		  var type = "";
		  if(he_labels.length > 0){
		    type = he_labels[0].getAttribute("type");
		  }
		  var added = draw_hyperedge(x.getAttribute("xml:id"),type);
		  if(added.length != 0)
		    mark_secondaries(x);
		  selected = [];
		  extraselected = [];
		});

	      metaedges_nodes.forEach((x) => {
		  var metaedge_nodes = metaedges_arcs.
		              filter((y) => {return y[0] == x;}).
			      map((y) => {return [y[2],get_by_id(document,y[1])];})
	          selected = metaedge_nodes.
		              filter((y) => {return y[0] == "secondary";}).
			      map((y) => { return y[1];});
	          extraselected = metaedge_nodes.
		              filter((y) => {return y[0] == "primary";}).
			      map((y) => { return y[1];});
	          var me_labels = x.getElementsByTagName("label");
		  var type = "";
		  if(me_labels.length > 0){
		    type = me_labels[0].getAttribute("type");
		  }
		  var added = draw_metaedge(x.getAttribute("xml:id"),type);
		  selected = [];
		  extraselected = [];
		});


	    }
            
            // Do all of this when we have the MEI in memory
            function load_finish(e) {
	      data = reader.result;
	      parser = new DOMParser();
	      mei = parser.parseFromString(data,"text/xml");
	      format = "mei";
	      if(mei.documentElement.namespaceURI != "http://www.music-encoding.org/ns/mei")
		// We didn't get a MEI? Try if it's a musicXML
		format = "musicxml";
	      svg = vrvToolkit.renderData(data, {pageWidth: 20000,
		  pageHeight: 10000, breaks: "none", format: format});
	      $("#svg_output").html(svg);
	      if(format == "musicxml"){
		data = vrvToolkit.getMEI();
		parser = new DOMParser();
		mei = parser.parseFromString(data,"text/xml");
	      }

	      mei_graph = add_or_fetch_graph();
	      orig_mei = mei;
	      orig_data = data;
	      orig_mei_graph = mei_graph;
	      orig_svg = svg;

	      draw_graph();

	      changes = false;
	      undo_actions = [];
	      redo_actions = []; //TODO, maybe?
	      reduce_actions = [];

	      rerendered_after_action = 0;

	      for (let n of document.getElementsByClassName("note")) {
		  //n.addEventListener('click', function(ev) {toggle_selected(n,ev.shiftKey) } )
		  n.onclick = function(ev) {toggle_selected(n,ev.shiftKey) };
	      }
	      for (let h of document.getElementsByClassName("hyperedge")) {
		  h.onclick = function(ev) {toggle_selected(h,ev.shiftKey) };
		  //h.addEventListener('click', function(ev) {toggle_selected(h,ev.shiftKey) } )
	      }
	      if(!shades)
		toggle_shades();
	      document.onkeypress = function(ev) {handle_keypress(ev);};
	    }



            function rerender(output) {
	      var mei2 = mei.implementation.createDocument(
		    mei.documentElement.namespaceURI, //namespace to use
		    null,             //name of the root element (or for empty document)
		    null              //doctype (null for XML)
		    );
	      var newNode = mei2.importNode(
		  mei.documentElement, //node to import
		  true                 //clone its descendants
		  );
	      mei2.appendChild(newNode);

	      Array.from(document.getElementsByClassName("note")).forEach((x) => {
		if(x.style.visibility == "hidden"){
		  //TODO: this is wrong
		  // 
		  var y = get_by_id(mei2,x.getAttribute("id"));
		  y.parentNode.removeChild(y);
		}
	      });
	      Array.from(mei2.getElementsByTagName("chord")).forEach((x) =>
		{
		if(x.getElementsByTagName("note").length == 0){
		  x.parentNode.removeChild(x);
		}
		});

	      var data2 = new XMLSerializer().serializeToString(mei2);

	      var svg2 = vrvToolkit.renderData(data2, {pageWidth: 20000,
		  pageHeight: 10000, breaks: "none", format: "mei"});

	      $("#svg_output").html(svg2);
	      svg = svg2;
	      mei = mei2;
	      data = data2;
	      mei_graph = add_or_fetch_graph();
	      for (let n of document.getElementsByClassName("note")) {
		  n.onclick= function(ev) {toggle_selected(n,ev.shiftKey) };
	      }
	      if(non_notes_hidden)
		set_non_note_visibility("hidden");
	      // Need also to redraw edges and hyperedges
	      draw_graph();

	      // Can't undo after a rerender.. yet, TODO: Make layers
	      rerendered_after_action=undo_actions.length;
	      // This is one of the ugliest hacks I've made I think
	      var reduces = undo_actions.filter((x) => { return x[0] == "reduce";});
	      reduces.forEach((action) => {selected = action[2]; do_reduce();})
	      undo_action = [];

	    }

            function rerender_temp() {
	      // Create new SVG element, stack the current version on
	      // it..? No I have no idea how to UI this properly.
	      rerender();
	    }

            function texton() { text_input = true; }
            function textoff() { text_input = false; }
	    function show_buttons() {
	      $("#load_save")[0].style.display="";
	      $("#hidden_buttons")[0].style.display="none";
	    }
	    function hide_buttons() {
	      $("#load_save")[0].style.display="none";
	      $("#hidden_buttons")[0].style.display="";
	    }

            function zoom_in() {
	      zoom = zoom * 1.1;
	      $("#svg_output")[0].style.transform="scale("+zoom+")";
	    }
            function zoom_out() {
	      zoom = zoom * 0.90909090909090;
	      $("#svg_output")[0].style.transform="scale("+zoom+")";
	    }


            function do_deselect() {
	      selected.forEach((x) => toggle_selected(x));
	      extraselected.forEach((x) => toggle_selected(x,true));
	    }





        </script>
	<div id="selected_things" style="position:fixed; fill-opacity: 0.5;
	stroke-opacity: 0.5">Primaries:<br/>Secondaries:</div>
	<div id="hidden_buttons" style="position:fixed; bottom:0; z-index:2 ; display:none">
	<input type=button id="showbutton" value="Show" onclick="show_buttons()">
	</div>
	<div id="load_save" style="position:fixed; bottom:0; z-index:2">
	  <input type="button" id="undobutton" value="(U)ndo" onclick="do_undo()">
	  <input type="button" id="deselectbutton" value="Deselect all" onclick="do_deselect()">
	  <input type="button" id="deletebutton" value="Delete hyperedges" onclick="delete_hyperedges()" >
	  <!--input type="button" id="edgebutton" value="Add untyped edges" onclick="do_edges()" -->
	  <input type="button" class="hyperedgebutton" id="hyperedgebutton" value="Add untyped hyperedge" onclick="do_hyperedge()" > 
	  <input type="button" class="hyperedgebutton" id="customhyperedgebutton" value="Add hyperedge with custom type:" onclick="do_hyperedge($('#custom_type')[0].value)" >
	  <input type="text" id="custom_type" onfocus="texton()" onblur="textoff()">
	  <div id="relation_buttons">
	  </div>
	  <input type="button" id="hidebutton" value="Hide" onclick="hide_buttons()">
	  <input type="file" id="fileupload" value="Load" onchange="load()" >
	  <!--input type="button" id="uploadbutton" value="Load" onclick="load()" -->
	  <!--input type="button" id="downloadbutton" value="Save" onclick="save()" -->
	  <input type="button" id="downloadbutton" value="Save" onclick="save_orig()" >
	  <input type="button" id="svgdownloadbutton" value="Save SVG" onclick="savesvg()" >
	  <input type="button" id="reducebutton" value="(R)educe Hyperedges" onclick="do_reduce()" >
	  <input type="button" id="equalizebutton" value="Toggle (s)tems etc." onclick="toggle_equalize()" >
	  <input type="button" id="shadesbutton" value="Toggle type s(h)ades." onclick="toggle_shades()" >
	  <input type="button" id="rerenderbutton" value="Rerender less hidden notes" onclick="rerender_temp()" >
	  <!--input type="button" id="selectifybutton" value="Select similar notes" onclick="select_samenote()" --> <br/>

	</div>
	<div id="zoom buttons" style="position:fixed; top:0; right:0; z-index:2">
	<input type="button" class="zoombutton" value="+" onclick="zoom_in()"><br/>
	<input type="button" class="zoombutton" value="-" onclick="zoom_out()"><br/>
	</div>


        <!--//////////////////////////////////////////////-->
        <!-- The div where we are going to insert the SVG -->
        <!--//////////////////////////////////////////////-->
	
	<div style="transform-origin: top left; z-index:-1" id="svg_output"></div>



    </body>
</html>
